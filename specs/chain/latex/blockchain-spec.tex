\documentclass[11pt,a4paper]{article}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{extarrows}
\usepackage{float}
\usepackage[margin=2.5cm]{geometry}
\usepackage[unicode=true,pdftex,pdfa]{hyperref}
\usepackage[capitalise,noabbrev,nameinlink]{cleveref}
\usepackage[utf8]{inputenc}
\usepackage{latexsym}
\usepackage{listings}
\usepackage{mathpazo} % nice fonts
\usepackage{mathtools}
\usepackage{microtype}
\usepackage[colon]{natbib}
%%
%% Package `semantic` can be used for writing inference rules.
%%
\usepackage{semantic}
\usepackage{slashed}
\usepackage{stmaryrd}
\usepackage[colorinlistoftodos,prependcaption,textsize=tiny]{todonotes}

\hypersetup{
  pdftitle={Specification of the Blockchain Layer},
  breaklinks=true,
  bookmarks=true,
  colorlinks=false,
  linkcolor={blue},
  citecolor={blue},
  urlcolor={blue},
  linkbordercolor={white},
  citebordercolor={white},
  urlbordercolor={white}
}
\floatstyle{boxed}
\restylefloat{figure}

%% Setup for the semantic package
\setpremisesspace{20pt}

\DeclareMathOperator{\dom}{dom}
\DeclareMathOperator{\range}{range}

%%
\newcommand{\powerset}[1]{\mathbb{P}~#1}
\newcommand\Set[2]{\{\,#1\mid#2\,\}}
\newcommand{\restrictdom}{\lhd}
\newcommand{\subtractdom}{\mathbin{\slashed{\restrictdom}}}
\newcommand{\restrictrange}{\rhd}
\newcommand{\union}{\cup}
\newcommand{\unionoverride}{\mathbin{\underrightarrow\cup}}
\newcommand{\uniondistinct}{\uplus}
\newcommand{\var}[1]{\mathit{#1}}
\newcommand{\fun}[1]{\mathsf{#1}}
\newcommand{\type}[1]{\mathsf{#1}}
\newcommand{\size}[1]{\left| #1 \right|}
\newcommand{\trans}[2]{\xlongrightarrow[\textsc{#1}]{#2}}
\newcommand{\seqof}[1]{#1^{*}}
\newcommand{\nextdef}{\\[1em]}

%%
%% Types
%%
\newcommand{\Hash}{\type{Hash}}    % addresses as verification key hashes
\newcommand{\BHash}{\type{BHash}}  % block hashes
\newcommand{\Addr}{\type{Addr}}
\newcommand{\Slot}{\type{Slot}}
\newcommand{\BlockIx}{\type{BlockIx}}
\newcommand{\GBlock}{\type{GBlock}}
\newcommand{\RBlock}{\type{RBlock}}
\newcommand{\Block}{\type{Block}}
\newcommand{\HCert}{\type{C}}
\newcommand{\Queue}{\type{Q}}

\newcommand{\SKey}{\type{SKey}}
\newcommand{\SKeyGen}{\type{SKey_G}}
\newcommand{\VKey}{\type{VKey}}
\newcommand{\VKeyGen}{\type{VKey_G}}
\newcommand{\Sig}{\type{Sig}}
\newcommand{\Data}{\type{Data}}

%%
%% Function and relation names
%%
\newcommand{\hashname}{bHash}
\newcommand{\signname}{sign}
\newcommand{\verifyname}{verify}
\newcommand{\keypairname}{pair}
\newcommand{\delegatorname}{delegator} % the delegator of a delegatee in a given slot
\newcommand{\signmapname}{\mathcal{M}}
\newcommand{\trimixname}{trimIx}
\newcommand{\incixmapname}{incIxMap}
\newcommand{\postnewcertsname}{postNewCerts}

\newcommand{\bdataname}{bData}
\newcommand{\bcertsname}{bCerts}
\newcommand{\bsigname}{bSig}
\newcommand{\bixname}{bIx}
\newcommand{\bslname}{bSl}

\newcommand{\qrestrname}{qRestrict}
\newcommand{\qpopname}{qPop}
\newcommand{\qheadname}{qHead}
\newcommand{\qpushname}{qPush}

%% 
%% Functions and relations
%%
\newcommand{\sign}[4]{\fun{\signname}\ #1 ~ #2 ~ #3 ~ #4}
\newcommand{\verify}[3]{\fun{\verifyname} ~ #1 ~ #2 ~ #3}
\newcommand{\hash}[1]{\fun{\hashname}\ #1}
\newcommand{\pair}[2]{\fun{\keypairname} ~ #1 ~ #2}
\newcommand{\delegator}[2]{\fun{\delegatorname} ~ #1 ~ #2}
\newcommand{\signmap}[1]{\fun{\signmapname} ~ #1}
\newcommand{\qrestr}[2]{\fun{\qrestrname} ~ #1 ~ #2}
\newcommand{\trimix}[2]{\fun{\trimixname} ~ #1 ~ #2}
\newcommand{\incixmap}[3]{\fun{\incixmapname} ~ #1 ~ #2 ~ #3}
\newcommand{\postnewcerts}[1]{\fun{\postnewcertsname} ~ #1}

\newcommand{\bdata}[1]{\fun{\bdataname} ~ #1}
\newcommand{\bcerts}[1]{\fun{\bcertsname} ~ #1}
\newcommand{\bsig}[1]{\fun{\bsigname} ~ #1}
\newcommand{\bix}[1]{\fun{\bixname} ~ #1}
\newcommand{\bsl}[1]{\fun{\bslname} ~ #1}

\newcommand{\qpop}[1]{\fun{\qpopname} ~ #1}
\newcommand{\qhead}[1]{\fun{\qheadname} ~ #1}
\newcommand{\qpush}[1]{\fun{\qpushname} ~ #1}

\newcommand{\delmap}{\delta}

% Partial and total function aliases
\newcommand{\totalf}{\to}
\newcommand{\partialf}{\mapsto}

% A type alias for a map from a genesis block verification key to a queue of indices
\newcommand{\mapqueue}{\mathcal{Q}}
% comments
\newcommand{\marko}[1]{\todo[size=\small, color=yellow!40, inline]{Marko: #1}}

\begin{document}


\title{Specification of the Blockchain Layer}

\author{Marko DimjaÅ¡eviÄ‡}

\date{October 26, 2018}

\maketitle

\begin{abstract}
This documents defines a semantics for operations on a blockchain.
%
In particular, a block validity definition is given, which is accompanied by
small-step operational semantics inference rules.
\end{abstract}

\tableofcontents
\listoffigures

\section{Introduction}
\label{sec:introduction}

The idea behind this document is to formalise what it means for a new block to
be added to the blockchain to be valid.
%
Unless a new block is valid, it cannot be added to the blockchain and thereby
extend it.
%
This is needed for a system that is subscribed to the blockchain and keeps a
copy of it locally.
%
In particular, this document gives a formalisation that should be
straightforward to implement in a programming language, e.g., in Haskell.


\section{Preliminaries}
\label{sec:preliminaries}

\begin{description}
\item[Powerset] Given a set $\type{X}$, $\powerset{\type{X}}$ is the set of all
  the subsets of $X$.
\item[Sequence] Given a set $\type{X}$, $\seqof{\type{X}}$ is a sequence
  having elements taken from $\type{X}$.
  %
  The empty sequence is denoted by $\epsilon$, and given a sequence $\Lambda$,
  $\Lambda; x$ is the sequence that results from appending
  $x \in \type{X}$ to $\Lambda$.
  %
  Furthermore, $\epsilon$ is an identity element for sequence joining:
  $\epsilon; x = x; \epsilon = x$.
\item[Option type] An option type in type $A$ is denoted as $A^? = A + 1$. The
  $A$ case corresponds to a case when there is a value of type $A$ and the $1$
  case corresponds to a case when there is no value.
\item[Union override] The union override operation is defined in
  Figure~\ref{fig:unionoverride}.
  %
  \begin{figure}
    \begin{align*}
      \var{K} \restrictdom \var{M}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ i \in \var{K} \}
      & \text{domain restriction}
      \\
      \var{K} \subtractdom \var{M}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ i \notin \var{K} \}
      & \text{domain exclusion}
      \\
      \var{M} \restrictrange \var{V}
      & = \{ i \mapsto o \mid i \mapsto o \in \var{M}, ~ o \in \var{V} \}
      & \text{range restriction}
      \\
      & \unionoverride \in (A \mapsto B) \to (A \mapsto B) \to (A \mapsto B)
      & \text{union override}\\
      & d_0 \unionoverride d_1 = d_1 \cup (\dom d_1 \subtractdom d_0)
    \end{align*}
    \caption{Definition of the Union Override Operation}
    \label{fig:unionoverride}
  \end{figure}
\end{description}

\section{Basic definitions}
\label{sec:basic-definitions}

This section gives definitions of basic types and functions that operate on
and with blocks and heavyweight delegation certificates.


\subsection{Heavyweight Delegation Certificates}
\label{sec:certificates}

A heavyweight delegation certificate is a proof that a genesis block
verification key $vk_s$ is delegating its right to sign a block to a signing
key $sk_d$, which has a corresponding verification key $vk_d$, starting with a
slot $sl$, which is confirmed by a cryptographic signature $\sigma$.
%
The type for a heavyweight delegation certificate is kept abstract in this
document, but it is a product type with projection functions for the
following:
%
\begin{itemize}
\item a delegator key,
\item a delegatee key,
\item a slot, and
\item a cryptographic signature.
\end{itemize}

Basic types and functions pertaining to heavyweight delegation certificates
are given in Figure~\ref{fig:cert-defs}.

\begin{figure}
  \emph{Primitive types}
  %
  \begin{align*}
    sl & \in \Slot    & \text{slot time-stamp}\\
   sig & \in \Sig     & \text{cryptographic signature}\\
    sk & \in \SKey    & \text{signing key}\\
    vk & \in \VKey    & \text{verification key}\\
  \end{align*}
  %
  \emph{Derived types}
  %
  \begin{align*}
    vk_s & \in \VKeyGen \subseteq \VKey & \text{genesis block's verification key}\\
  \end{align*}
  %
  \emph{Abstract types}
  %
  \begin{align*}
    c & \in \HCert  & \text{heavyweight delegation certificate} \\
  \end{align*}
  %
  \emph{Functions}
  %
  \begin{align*}
    \text{$\fun{cFrom}$} & \in \HCert \totalf \VKeyGen & \text{certificate delegator key projection} \\
    \text{$\fun{cTo}$} & \in \HCert \totalf \VKey & \text{certificate delegatee key projection} \\
    \text{$\fun{cSl}$} & \in \HCert \totalf \Slot & \text{certificate slot projection} \\
    \text{$\fun{cSig}$} & \in \HCert \totalf \Sig & \text{certificate signature projection}
  \end{align*}
  %
  \caption{Basic Heavyweight Delegation Certificate-related Types and Functions}
  \label{fig:cert-defs}
\end{figure}


\subsection{Blocks}
\label{sec:blocks}

A block is an element of a blockchain.
%
A blockchain is extended by appending a block.
%
There are two types of blocks.
%
The first type is the genesis block, denoted by $\GBlock$ in this document.
%
Every blockchain starts with a genesis block.
%
A genesis block contains a set of $n$ verification keys.
%
These keys are often referred to as the genesis block verification keys.
%
A genesis block also contains a hash.
%
In this document $\GBlock$ is kept abstract, but it is a product type with
projection functions for the two just mentioned values:
%
\begin{itemize}
\item a set of $n$ verification keys, and
\item a block hash.
\end{itemize}

The second type is for a non-genesis block, denoted by $\RBlock$.
%
In this document $\RBlock$ is kept abstract, but it is a product type with
projection functions for the following:
%
\begin{itemize}
\item a block index,
\item a block hash pointing to the block's predecessor,
\item a slot it is in,
\item a set of heavyweight delegation certificates in the body, and
\item a cryptographic signature.
\end{itemize}


Basic types and functions pertaining to blocks are given in
Figure~\ref{fig:block-defs}.

\begin{figure}
  \emph{Primitive types}
  %
  \begin{align*}
    ix & \in \BlockIx & \text{block index}\\
     h & \in \BHash   & \text{block hash}\\
  \end{align*}
  %
  \emph{Abstract types}
  %
  \begin{align*}
    r & \in \RBlock & \text{non-genesis block} \\
    g & \in \GBlock & \text{genesis block} \\
  \end{align*}
  %
  \emph{Derived types}
  %
  \begin{align*}
    b & \in \Block = \GBlock + \RBlock & \text{block} \\
  \end{align*}
  %
  \emph{Functions}
  %
  \begin{align*}
    \text{$\fun{gbKeys}$} & \in \GBlock \totalf \VKeyGen^n & \text{block keys projection} \\
    \text{$\fun{\bixname}$} & \in \RBlock \totalf \BlockIx & \text{block index projection} \\
    \text{$\fun{\hashname}$} & \in \Block \totalf \BHash
      & \text{block hash projection} \\
    \text{$\fun{\bslname}$} & \in \RBlock \totalf \Slot & \text{block slot projection} \\
    \text{$\fun{\bcertsname}$} & \in \RBlock \totalf \powerset{\HCert}
      & \text{block certificates projection} \\
    \text{$\fun{\bsigname}$} & \in \RBlock \totalf \Sig & \text{block signature projection} \\
    \text{$\fun{\bdataname}$} & \in \RBlock \totalf \Data & \text{block data projection}
  \end{align*}
  %
  \caption{Basic Block-related Types and Functions}
  \label{fig:block-defs}
\end{figure}


\section{Auxiliary definitions}
\label{sec:auxil-defin}
TODO: Put this note on serialisation somewhere more appropriate.

If $s(\cdot)$ is a function for serialising data and $d(\cdot)$ a function for
deserialising data, their composition $s \circ d$ is not an identity function:
%
this is hard to enforce and it is considered a bad practice in cryptography
design.

% \section{Delegation}
% \label{sec:delegation}

% \marko{This section might be out of date. There is a work in progress to come
%   up with an interface between the blockchain layer and the ledger layer.
%   %
%   See CDEC-638.}

% The genesis block contains verification keys of $n$ servers.
% %
% As of mid-October 2018, $n = 7$.
% %
% Each of $n$ servers keeps its own corresponding signing key locally and does
% not share the signing key with anyone else.
% %
% Only signing keys with their verification counterparts in the genesis block
% have the right to sign blocks.
% %
% However, by the means of delegation certificates, keys from the genesis block
% can delegate the signing right to other keys.
% %
% Delegation is not transitive, i.e., there is no chaining of delegation:
% %
% only genesis block keys can delegate.


% \subsection{Delegation Design}
% \label{sec:delegation-design}

% To keep track of active certificates and when they become valid, a map from
% genesis block verification keys to a list of certificates is used.
% %
% A certificate contains an epoch in which it becomes valid.
% %
% Each list is sorted by epochs from certificates in the decreasing order (i.e.,
% a certificate with an earlier epoch comes latter in the list).
% %
% The map is initialised by each genesis block key delegating to itself.


% If a new certificate is to be posted and added to the map, first it is
% checked.
% %
% The epoch when a certificate becomes valid has to be greater than the epoch of
% the head certificate of the corresponding list.
% %
% The certificate has to have a valid signature.
% %
% If the certificate is valid, it is prepended to the list of the map key that
% is delegating.
% %
% This also takes care of the property that no key can delegate
% twice in an epoch.


% Each list in the map is trimmed at the beginning of each epoch by keeping only
% the head of the list, i.e., by keeping only one certificate.
% %
% This head certificate is either a new certificate that becomes valid in this
% epoch or it is an old certificate that is still valid and it was not replaced
% by any new delegation certificate.
% %
% Due to trimming, each list in the map has at most two certificates at any
% point in time.
% %
% At the beginning of an epoch, a list has only one element and at any other
% point it can have at most two elements (i.e., two certificates) if there was a
% new delegation certificate for the next epoch posted.


% Because one key's delegation can be changed only for the next epoch, but
% not for the current epoch or any epoch after the next, checking whom the key
% currently delegates to is a constant-time operation: only the head and
% possibly the second item in the list have to be examined.

% This approach also supports certificate revocation: it is done by posting a
% certificate in which a key delegates to itself.


\section{Delegation Interface}
\label{sec:del-interface}

The blockchain layer and the ledger layer need to communicate delegation
certificates for the purpose of signing new blocks.
%
To enable this communication, there is a delegation interface between the two
layers.
%
The interface communicates the minimum of information needed to enable
delegation.


Given that delegation certificates are in the body of a block just like
transactions are, the ledger layer keeps track of the state of certificates.
%
It does so by keeping a set of certificates that are currently active.
%
Furthermore, the ledger layer also needs to maintain a set of delegation
certificates that have been added to the blockchain, but that will become
active and that possibly inactive other certificates in the future.
%
As part of the delegation interface, the ledger layer exposes functionality
for checking if a particular verification key has the delegation right to sign
a block in a given slot.
%
In particular, if the verification key has the right to sign, the
functionality should inform who is the delegator.
%
In Haskell, the signature of the corresponding function is:
%
\begin{lstlisting}
delegator :: ( VKey vk_d, VKeyGen vk_s)
          => vk_d -> Slot s -> Maybe vk_s
\end{lstlisting}

If the verification key does not have the delegation right, i.e., it has no
right to sign the block in the given slot, the function returns nothing.
%
If it does have the right, it returns the delegator's verification key.
%
Note that in the case when $vk_d \in VKeyGen$, i.e., when the verification key
is a genesis block verification key, and it has not delegated its signing
right to any other key, the function should return that same genesis block
verification key.


New delegation certificates are added to the blockchain in blocks, so the
blockchain layer has to inform the ledger layer of new certificates when a new
block is to be added to the blockchain.
%
Therefore, as part of the delegation interface, the blockchain layer exposes
new delegation certificates functionality to the ledger layer.
%
In Haskell, the signature of the corresponding function is:
%
\begin{lstlisting}
postNewCerts :: (HCert c, MonadError CertErr m) => Set c -> m ()
\end{lstlisting}
%
The return type of the function signals the possibility of failure.
%
Given that the blockchain layer does not keep the state of delegation
certificates, it has no way of checking if certificates are valid.
%
For example, the blockchain layer cannot know if the delegator already posted
another delegation certificate in the current epoch.
%
Furthermore, the slot in which the certificate is claimed to become active
might not be in K slots, which should disallow such a certificate.
%
In case of failure, the whole block to be added to the blockchain is
discarded.


\section{State transitions for Blockchain}
\label{sec:state-trans-chain}

\begin{figure}[h]
  \emph{Primitive types}
  %
  \begin{align*}
  data & \in \Data    & \text{data}
  \end{align*}
  %
  \emph{Derived types}
  %
  \begin{align*}
    sk_s & \in \SKeyGen \subseteq \SKey & \text{genesis block's signing key}\\
  \end{align*}
  %
  \emph{Functions and relations}
  %
  \begin{align*}
    \text{$\fun{\keypairname}$} & \in \SKey \times \VKey & \text{key pair relation}\\
    \text{$\fun{\signname}$} & \in \SKey \times \BHash \times \Slot \times \Data \partialf \Sig
      & \text{signature function}\\
    \text{$\fun{\verifyname}$} & \in \VKey \times \Data \times \Sig
      & \text{verification relation}\\
    \text{$\fun{\delegatorname}$} & \in \VKey \times \Slot \partialf \VKeyGen^?
      & \text{delegator function}
  \end{align*}
  \caption{Definitions associated with the blockchain transition system}
  \label{fig:state-trans-abstract}
\end{figure}

% \subsection{Delegation}
% \label{sec:delegation-properties}

% \marko{This whole subsection on delegation rules is out of date.
%   %
%   See the ledger layer specification for delegation rules.}

% In the first epoch, every key from the genesis block delegates to itself, as given by \eqref{eq:init-delpmap}.

% \begin{equation}
%   \label{eq:init-delpmap}
%   \inference[Initial-delegation-map]
%   {}
%   { \delmap_0 = \Set{(vk_s \partialf c; \epsilon)}{vk_s \in \VKeyGen \wedge c = (vk_s, vk_s, e_0, \sigma)}}
% \end{equation}


% When an epoch clock ticks and the current epoch with an index $k$ changes to
% an epoch with an index $k+1$, each list in the delegation map is shrunk to its
% head element, as given by \eqref{eq:next-epoch-delmap}.

% \begin{equation}
%   \label{eq:next-epoch-delmap}
%   \inference[Epoch-change]
%   {\delmap_k & \text{epoch clock tick}}
%   {\delmap_k \trans{}{} {\delmap_{k+1} = \Set{(vk_s \partialf c; \epsilon)}{(vk_s \partialf c; \Lambda) \in \delmap_k}}}
% \end{equation}


% If a new valid delegation certificate $c = (vk_s, vk_d, e_j, \sigma)$ that is
% a proof that $vk_s$ delegates to $vk_d$ starting in epoch $e_j$ is to be
% added, the delegation map is updated at $vk_s$, as given by
% \eqref{eq:new-del-cert}.

% \begin{equation}
%   \label{eq:new-del-cert}
%   \inference[New-certificate]
%   {
%     {
%       \begin{array}{c}
%         (sk_s, vk_s) \in \SKeyGen \times \VKeyGen \\
%         (vk_s \partialf c_h; \lambda) \in \delmap_k \\
%         c_h = (vk_s, vk_{d_1}, e_h, \sigma_h)
%       \end{array}
%     }
%     &
%     {
%       \begin{array}{c}
%         c = (vk_s, vk_d, e_j, \sigma) \\
%         e_j > e_h
%       \end{array}
%     }
%   }
%   {\delmap_k \trans{}{}
%     \left(
%     {
%       \begin{array}{c}
%         \delmap_{k'} = \Set{(vk \partialf \Lambda)}{(vk \partialf \Lambda) \in \delmap_k \wedge vk \neq vk_s} \cup \{vk_s \partialf c; c_h; \epsilon\} \\
%         \delegate{sk_s}{vk_d} = (vk_s, vk_d, e_j, \sigma)
%       \end{array}
%     }
%     \right)
%   }
% \end{equation}


\subsection{Block Validity}
\label{sec:block-valid}
% This definition is adopted from shelley-plan.md, which is written by
% Duncan Coutts

A non-genesis block $\var{b}$ is valid if:
%
\begin{enumerate}
\item it is signed by a signing key $sk_d$ for which a valid heavyweight
  delegation certificate $c$ that is active at the time of signing exists.
  %
  The certificate $c$ carries information that signing rights from a genesis
  block verification key $vk_s$ are transferred to a verification key $vk_d$
  starting in a slot $sl$,
\item the corresponding certificate $c$ is signed by a key $sk_s$ that has a
  corresponding verification key in the genesis block.
  %
  The certificate therefore carries a a cryptographic signature $\sigma'$,
  and
\item in the rolling window of the last $K$ blocks, the number of blocks
  signed by keys that $sk_s$ delegated to is no more than a threshold
  $K \cdot t$, where $t$ is a constant\footnote{This is not the same $t$ from
    the Ouroboros BFT paper draft where it denotes the number of Byzantine
    servers, though it should be somehow related to it.}  that will be picked
  in the range $1/5 \leq t \leq 1/4$.
\end{enumerate}

Relationship between the $\text{\signname}$ function and the
$\text{\verifyname}$ relation is given by \eqref{eq:sign-verify}:

\begin{equation}
  \label{eq:sign-verify}
  \forall (sk, vk) \in \text{\keypairname}, b = (h, sl, d, \sigma) \in \Block.\
  \verify{vk}{d}{\sigma} \iff \sign{sk}{h}{sl}{d} = \sigma.
\end{equation}


\subsection{Counting Signed Blocks}
\label{sec:counting-signed-blocks}

To make sure no signing key with a corresponding genesis block verification
key gets to sign too many blocks, a state is maintained by keeping a mapping
of keys to a queue of signed blocks in a sliding window of at most K last
blocks in the blockchain.
%
Initially, when the blockchain is made of the genesis block $g_0 \in \GBlock$
only, and no key from the genesis block signed a block (neither directly or
indirectly via delegation), as given by \eqref{eq:init-bc-state}.

\begin{equation}
  \label{eq:init-bc-state}
  \inference[Initial-state]
  {}
  {\left(
      {\begin{array}{c}
        \signmapname = \emptyset \\
        p = g_0
      \end{array}}
  \right)
  }
\end{equation}
%
With $p$ we denote the last block that was added to the blockchain.
%
The type of map $\signmapname$ is given in
Figure~\ref{fig:block-ext-types-funs}.

Once a new block arrives, map $\signmapname$ has to be updated.
%
In particular, if a block with an index $ix$ signed by a signing key
corresponding to a verification key $vk_d$ is to be added to the blockchain,
the sliding window of the last $K$ blocks moves by one block and the map
$\signmapname$ has to be updated for the key that signed the $K^{\text{th}}$
previous block;
%
this is done with $\trimix{\signmapname}{ix}$, as given by
\eqref{eq:trimix}.
%
To finish updating the map, the updated version of $\signmapname$ denoted by
$\signmapname'$ has to push $ix$ to the queue for $vk_s$, which is achieved
with $\incixmap{vk_s}{\signmapname'}{ix}$, as given by
\eqref{eq:incixmap}.
%
Types of both of these functions are given in
Figure~\ref{fig:block-ext-types-funs}.


\begin{align}
  \label{eq:trimix}
  \trimix{\signmapname}{ix} = \Set{(vk_s \partialf q)}{vk_s \in \dom \signmapname.~
  q = \qrestr{ix}{(\signmap{vk_s}})} \\
  \qrestr{ix}{q} = \
  \begin{cases}
    \qpop{q} & \text{if } \size{q} > 0 \wedge \qhead{q} + K < ix \\
    q & \text{otherwise}
  \end{cases}
\end{align}

\begin{equation}
  \label{eq:incixmap}
  \incixmap{vk_s}{\signmapname'}{ix} = ?
\end{equation}


\begin{figure}
  \emph{Abstract types}
  %
  \begin{align*}
    q & \in \Queue_\BlockIx  & \text{block index queue}
  \end{align*}
  %
  \emph{Derived types}
  %
  \begin{align*}
    \signmapname & \in \VKeyGen \totalf \Queue_\BlockIx & \text{key to block index map}
  \end{align*}
  %
  \emph{Type aliases}
  %
  \begin{align*}
    \mapqueue = \VKeyGen \totalf \Queue_\BlockIx
  \end{align*}
  \emph{Functions}
  %
  \begin{align*}
    \text{$\fun{qHead}$} & \in \Queue_\BlockIx \totalf \BlockIx^? & \text{head of queue function} \\
    \text{$\fun{qPush}$} & \in \BlockIx \times \Queue_\BlockIx \totalf \Queue_\BlockIx
      & \text{queue push function} \\
    \text{$\fun{\qpopname}$} & \in \Queue_\BlockIx \totalf {\Queue_\BlockIx}^?
      & \text{queue pop function} \\
    \fun{\qrestrname} & \in \BlockIx \times \Queue_\BlockIx \totalf \Queue_\BlockIx
      & \text{restricted queue pop function} \\
    \text{$\fun{\trimixname}$} & \in \mapqueue \times \BlockIx \totalf \mapqueue
      & \text{old block removal function} \\
    \text{$\fun{\incixmapname}$} & \in \VKeyGen \times \mapqueue \times \BlockIx \totalf \mapqueue
      & \text{block count increment function}
  \end{align*}
  %
  \caption{Block Extension Types and Functions}
  \label{fig:block-ext-types-funs}
\end{figure}


\subsection{Blockchain Extension}
\label{sec:chain-extension}

A new block $b \in \RBlock$ with an index $ix \in BlockIx$, signed by a
signing key $sk_d$ in a slot $sl$ can extend a blockchain if the following
conditions are met:
%
\begin{enumerate}
\item $sk_d$ has a corresponding verification key $vk_d$ that has delegation
  rights for the slot $sl$, and
\item new delegation certificates that are in the body of $b$ are not in
  conflict with earlier delegation certificates.
\end{enumerate}

A rule capturing the blockchain extension is given in
Figure~\ref{fig:blockchain-extension}.

\begin{figure}
  \begin{equation*}
  \inference[Blockchain-extension]
  {
    {\begin{array}{c}
      ix = \bix{b} \wedge sl = \bsl{b} \\
      \hash{b} = h = p \\ % TODO: types have to be fixed for hashes
      vk_s = \delegator{vk_d}{sl} \wedge (sk_d, vk_d) \in \SKey \times \VKey \\
      \size{\signmap{vk_s}} \leq K \cdot t \wedge \sign{sk_d}{h}{sl}{(\bdata{b})} = \bsig{b} \\
      \signmapname' = \incixmap{vk_s}{(\trimix{\signmapname}{ix})}{ix} \\
      \mathcal{C} = \bcerts{b} \\
      \postnewcerts{\mathcal{C}} \\
      p' = b 
    \end{array}}
  }
  {
    \left(
      {\begin{array}{c}
         \signmapname \\
         p
       \end{array}}
    \right)
    \trans{}{b}
    \left(
      {\begin{array}{c}
         \signmapname' \\
         p'
       \end{array}}
    \right)
 }
  \end{equation*}
  \caption{Blockchain-extension}
  \label{fig:blockchain-extension}
\end{figure}

\end{document}


%%% Local Variables:
%%% mode: latex
%%% TeX-master: t
%%% End:
